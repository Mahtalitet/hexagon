<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SerializationPackage.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon</a> &gt; <a href="index.source.html" class="el_package">co.there4.hexagon.serialization</a> &gt; <span class="el_source">SerializationPackage.kt</span></div><h1>SerializationPackage.kt</h1><pre class="source lang-java linenums">package co.there4.hexagon.serialization

import com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY
import com.fasterxml.jackson.core.*
import com.fasterxml.jackson.core.JsonToken.*
import com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES
import com.fasterxml.jackson.databind.SerializationFeature.FAIL_ON_EMPTY_BEANS
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.deser.ContextualDeserializer
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.KotlinModule

import java.io.ByteArrayInputStream
import java.io.File
import java.io.InputStream
import java.net.URL
import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets.UTF_8
import java.time.LocalDate
import java.time.LocalTime
import java.util.*

import kotlin.reflect.KClass

<span class="fc" id="L27">val contentTypes = JacksonSerializer.contentTypes</span>
<span class="fc" id="L28">val defaultFormat = contentTypes.first()</span>

<span class="fc" id="L30">fun Any.convertToMap(): Map&lt;*, *&gt; = JacksonSerializer.toMap (this)</span>

fun &lt;T : Any&gt; Map&lt;*, *&gt;.convertToObject(type: KClass&lt;T&gt;): T =
<span class="fc" id="L33">    JacksonSerializer.toObject(this, type)</span>

fun &lt;T : Any&gt; List&lt;Map&lt;*, *&gt;&gt;.convertToObjects(type: KClass&lt;T&gt;): List&lt;T&gt; =
<span class="fc" id="L36">    this.map { it: Map&lt;*, *&gt; -&gt; it.convertToObject(type) }</span>

fun Any.serialize (contentType: String = defaultFormat) =
<span class="fc" id="L39">    JacksonSerializer.serialize(this, contentType)</span>

fun &lt;T : Any&gt; InputStream.parse (type: KClass&lt;T&gt;, contentType: String = defaultFormat) =
<span class="fc" id="L42">    JacksonSerializer.parse (this, type, contentType)</span>
<span class="fc" id="L43">fun InputStream.parse (contentType: String = defaultFormat) = this.parse (Map::class, contentType)</span>
fun &lt;T : Any&gt; InputStream.parseList (type: KClass&lt;T&gt;, contentType: String = defaultFormat) =
<span class="fc" id="L45">    JacksonSerializer.parseList (this, type, contentType)</span>
fun InputStream.parseList (contentType: String = defaultFormat) =
<span class="nc" id="L47">    this.parseList (Map::class, contentType)</span>

fun &lt;T : Any&gt; String.parse (type: KClass&lt;T&gt;, contentType: String = defaultFormat) =
<span class="fc" id="L50">    toStream(this).parse (type, contentType)</span>
<span class="fc" id="L51">fun String.parse (contentType: String = defaultFormat) = this.parse (Map::class, contentType)</span>
fun &lt;T : Any&gt; String.parseList (type: KClass&lt;T&gt;, contentType: String = defaultFormat) =
<span class="fc" id="L53">    toStream(this).parseList (type, contentType)</span>
<span class="fc" id="L54">fun String.parseList(contentType: String = defaultFormat) = this.parseList (Map::class, contentType)</span>

fun &lt;T : Any&gt; File.parse (type: KClass&lt;T&gt;) =
<span class="fc" id="L57">    this.inputStream().parse (type, &quot;application/&quot; + this.extension)</span>
<span class="fc" id="L58">fun File.parse () = this.parse (Map::class)</span>
fun &lt;T : Any&gt; File.parseList (type: KClass&lt;T&gt;): List&lt;T&gt; =
<span class="fc" id="L60">    this.inputStream().parseList (type, &quot;application/&quot; + this.extension)</span>
<span class="fc" id="L61">fun File.parseList () = this.parseList (Map::class)</span>

fun &lt;T : Any&gt; URL.parse (type: KClass&lt;T&gt;) =
<span class="fc" id="L64">    this.openStream().parse (type, &quot;application/&quot; + this.file.substringAfterLast('.'))</span>
<span class="fc" id="L65">fun URL.parse () = this.parse (Map::class)</span>
fun &lt;T : Any&gt; URL.parseList (type: KClass&lt;T&gt;): List&lt;T&gt; =
<span class="fc" id="L67">    this.openStream().parseList (type, &quot;application/&quot; + this.file.substringAfterLast('.'))</span>
<span class="fc" id="L68">fun URL.parseList () = this.parseList (Map::class)</span>

<span class="pc bpc" id="L70" title="1 of 2 branches missed.">private fun toStream(text: String) = ByteArrayInputStream(text.toByteArray(UTF_8))</span>

private fun JsonGenerator.writeNumbers(vararg numbers: Int) {
<span class="fc" id="L73">    writeStartArray()</span>
<span class="fc" id="L74">    numbers.forEach { writeNumber(it) }</span>
<span class="fc" id="L75">    writeEndArray()</span>
<span class="fc" id="L76">}</span>

private fun JsonToken.checkIs(expected: JsonToken) {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">    check (this == expected) { &quot;${this.name} should be: ${expected.name}&quot; }</span>
<span class="fc" id="L80">}</span>

internal fun createObjectMapper(mapperFactory: JsonFactory = MappingJsonFactory()): ObjectMapper {
<span class="fc" id="L83">    val mapper = ObjectMapper (mapperFactory)</span>
<span class="fc" id="L84">    mapper.configure (FAIL_ON_UNKNOWN_PROPERTIES, false)</span>
<span class="fc" id="L85">    mapper.configure (FAIL_ON_EMPTY_BEANS, false)</span>
<span class="fc" id="L86">    mapper.setSerializationInclusion (NON_EMPTY)</span>
<span class="fc" id="L87">    mapper.registerModule (Jdk8Module ())</span>
<span class="fc" id="L88">    mapper.registerModule (JavaTimeModule ())</span>
<span class="fc" id="L89">    mapper.registerModule (KotlinModule ())</span>
<span class="fc" id="L90">    mapper.registerModule (object : SimpleModule() {</span>
        init {
<span class="fc" id="L92">            addSerializer (ByteBuffer::class.java, ByteBufferSerializer)</span>
<span class="fc" id="L93">            addDeserializer (ByteBuffer::class.java, ByteBufferDeserializer)</span>
<span class="fc" id="L94">            addSerializer (LocalTime::class.java, LocalTimeSerializer)</span>
<span class="fc" id="L95">            addDeserializer (LocalTime::class.java, LocalTimeDeserializer)</span>
<span class="fc" id="L96">            addSerializer (LocalDate::class.java, LocalDateSerializer)</span>
<span class="fc" id="L97">            addDeserializer (LocalDate::class.java, LocalDateDeserializer)</span>
<span class="fc" id="L98">            addSerializer (ClosedRange::class.java, ClosedRangeSerializer)</span>
<span class="fc" id="L99">            addDeserializer (ClosedRange::class.java, ClosedRangeDeserializer)</span>
        }
    })
<span class="fc" id="L102">    return mapper</span>
}

<span class="fc" id="L105">internal object ByteBufferSerializer: JsonSerializer&lt;ByteBuffer&gt;() {</span>
    override fun serialize(value: ByteBuffer, gen: JsonGenerator, serializers: SerializerProvider) {
<span class="fc" id="L107">        gen.writeString (Base64.getEncoder ().encodeToString (value.array()))</span>
<span class="fc" id="L108">    }</span>
}

<span class="fc" id="L111">internal object ByteBufferDeserializer: JsonDeserializer&lt;ByteBuffer&gt;() {</span>
    override fun deserialize(p: JsonParser, ctxt: DeserializationContext): ByteBuffer =
<span class="fc" id="L113">        ByteBuffer.wrap (Base64.getDecoder ().decode (p.text))</span>
}

<span class="fc" id="L116">internal object LocalTimeSerializer: JsonSerializer&lt;LocalTime&gt; () {</span>
    override fun serialize(value: LocalTime, gen: JsonGenerator, serializers: SerializerProvider) {
<span class="fc" id="L118">        gen.writeNumbers(value.hour, value.minute, value.second, value.nano)</span>
<span class="fc" id="L119">    }</span>
}

<span class="fc" id="L122">internal object LocalTimeDeserializer: JsonDeserializer&lt;LocalTime&gt; () {</span>
    override fun deserialize(p: JsonParser, ctxt: DeserializationContext): LocalTime {
<span class="fc" id="L124">        p.currentToken.checkIs(START_ARRAY)</span>
<span class="fc" id="L125">        val result = LocalTime.of(</span>
            p.nextIntValue(0),
            p.nextIntValue(0),
            p.nextIntValue(0),
            p.nextIntValue(0)
        )
<span class="fc" id="L131">        p.nextToken().checkIs(END_ARRAY)</span>
<span class="fc" id="L132">        return result</span>
    }
}

<span class="fc" id="L136">internal object LocalDateSerializer: JsonSerializer&lt;LocalDate&gt; () {</span>
    override fun serialize(value: LocalDate, gen: JsonGenerator, serializers: SerializerProvider) {
<span class="fc" id="L138">        gen.writeNumbers(value.year, value.monthValue, value.dayOfMonth)</span>
<span class="fc" id="L139">    }</span>
}

<span class="fc" id="L142">internal object LocalDateDeserializer: JsonDeserializer&lt;LocalDate&gt; () {</span>
    override fun deserialize(p: JsonParser, ctxt: DeserializationContext): LocalDate {
<span class="fc" id="L144">        p.currentToken.checkIs(JsonToken.START_ARRAY)</span>
<span class="fc" id="L145">        val result = LocalDate.of(</span>
            p.nextIntValue(0),
            p.nextIntValue(0),
            p.nextIntValue(0)
        )
<span class="fc" id="L150">        p.nextToken().checkIs(END_ARRAY)</span>
<span class="fc" id="L151">        return result</span>
    }
}

<span class="fc" id="L155">internal object ClosedRangeSerializer: JsonSerializer&lt;ClosedRange&lt;*&gt;&gt; () {</span>
    override fun serialize(
        value: ClosedRange&lt;*&gt;, gen: JsonGenerator, serializers: SerializerProvider) {

<span class="fc" id="L159">        val start = value.start</span>
<span class="fc" id="L160">        val end = value.endInclusive</span>
<span class="fc" id="L161">        val valueSerializer = serializers.findValueSerializer(start.javaClass)</span>

<span class="fc" id="L163">        gen.writeStartObject()</span>

<span class="fc" id="L165">        gen.writeFieldName(&quot;start&quot;)</span>
<span class="fc" id="L166">        valueSerializer.serialize(start, gen, serializers)</span>

<span class="fc" id="L168">        gen.writeFieldName(&quot;endInclusive&quot;)</span>
<span class="fc" id="L169">        valueSerializer.serialize(end, gen, serializers)</span>

<span class="fc" id="L171">        gen.writeEndObject()</span>
<span class="fc" id="L172">    }</span>
}

<span class="fc" id="L175">internal object ClosedRangeDeserializer: JsonDeserializer&lt;ClosedRange&lt;*&gt;&gt; (), ContextualDeserializer {</span>
<span class="pc" id="L176">    private val valueType: ThreadLocal&lt;JavaType?&gt; = ThreadLocal.withInitial { null }</span>

    override fun createContextual(
        ctxt: DeserializationContext, property: BeanProperty): JsonDeserializer&lt;*&gt; {

<span class="fc" id="L181">        valueType.set(property.type.containedType(0))</span>
<span class="fc" id="L182">        return ClosedRangeDeserializer</span>
    }

    override fun deserialize(p: JsonParser, ctxt: DeserializationContext): ClosedRange&lt;*&gt; {
<span class="fc" id="L186">        p.currentToken.checkIs(START_OBJECT)</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        check(p.nextFieldName() == &quot;start&quot;) { &quot;Ranges should start with 'start' field&quot; }</span>
<span class="fc" id="L188">        p.nextToken() // Start object</span>
<span class="fc" id="L189">        val type = valueType.get()</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        @Suppress(&quot;UNCHECKED_CAST&quot;) val start = ctxt.readValue&lt;Any&gt;(p, type) as Comparable&lt;Any&gt;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        check(p.nextFieldName() == &quot;endInclusive&quot;) { &quot;Ranges should end with 'endInclusive' field&quot; }</span>
<span class="fc" id="L192">        p.nextToken() // End array</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        @Suppress(&quot;UNCHECKED_CAST&quot;) val end = ctxt.readValue&lt;Any&gt;(p, type) as Comparable&lt;Any&gt;</span>
<span class="fc" id="L194">        p.nextToken() // End array</span>
<span class="fc" id="L195">        return start .. end</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>