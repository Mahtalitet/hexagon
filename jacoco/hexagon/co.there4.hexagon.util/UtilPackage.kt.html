<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UtilPackage.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon</a> &gt; <a href="index.source.html" class="el_package">co.there4.hexagon.util</a> &gt; <span class="el_source">UtilPackage.kt</span></div><h1>UtilPackage.kt</h1><pre class="source lang-java linenums">package co.there4.hexagon.util

import java.io.InputStream
import java.lang.System.*
import java.lang.ThreadLocal.withInitial
import java.net.InetAddress.getLocalHost
import java.time.LocalDateTime
import java.util.*
import java.lang.management.ManagementFactory.getRuntimeMXBean
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneOffset.UTC
import java.lang.ClassLoader.getSystemClassLoader
import java.net.URL

/*
 * Timing
 * TODO Use Kotlin's kotlin.system.measureTimeMillis and remove these
 */

<span class="fc" id="L21">private val times = withInitial { LinkedList&lt;Long&gt; () }</span>

/**
 * Store a timestamp in nanoseconds in the thread's times stack.
 */
<span class="fc" id="L26">fun resetTimes() = times.get ().clear()</span>
/**
 * Store a timestamp in nanoseconds in the thread's times stack.
 */
<span class="fc" id="L30">fun pushTime() = times.get ().push(nanoTime())</span>
/**
 * Pop latest timestamp in the nanos times stack and returns the difference with current one.
 */
<span class="fc" id="L34">fun popTime() = nanoTime() - times.get().pop()</span>
/**
 * Returns a time difference in nanoseconds formatted as a string.
 */
<span class="fc" id="L38">fun formatTime(timestamp: Long) = &quot;%1.3f ms&quot;.format (timestamp / 1e6)</span>

/**
 * Formats a date as a formatted integer with this format: `YYYYMMDDHHmmss`.
 */
fun LocalDateTime.asInt () =
<span class="fc" id="L44">    (this.year       * 1e10.toLong()) +</span>
<span class="fc" id="L45">    (this.monthValue * 1e8.toLong()) +</span>
<span class="fc" id="L46">    (this.dayOfMonth * 1e6.toLong()) +</span>
<span class="fc" id="L47">    (this.hour       * 1e4.toLong()) +</span>
<span class="fc" id="L48">    (this.minute     * 1e2.toLong()) +</span>
<span class="fc" id="L49">    this.second</span>

<span class="fc" id="L51">fun LocalDateTime.toDate(): Date = Date.from(this.toInstant(UTC))</span>
<span class="nc" id="L52">fun LocalDate.toDate(): Date = this.atStartOfDay().toDate()</span>

fun Date.toLocalDateTime(): LocalDateTime =
<span class="nc" id="L55">    LocalDateTime.ofInstant(Instant.ofEpochMilli(this.time), UTC)</span>

<span class="nc" id="L57">fun Date.toLocalDate(): LocalDate = this.toLocalDateTime().toLocalDate()</span>

/*
 * Threading
 */

/** Map for storing context data linked to the executing thread. */
<span class="fc" id="L64">object Context {</span>
<span class="fc" id="L65">    private val threadLocal = withInitial { LinkedHashMap&lt;Any, Any&gt;() }</span>
<span class="fc" id="L66">    fun entries () = threadLocal.get().entries</span>
<span class="fc" id="L67">    operator fun get (key: Any) = threadLocal.get()[key]</span>
<span class="fc" id="L68">    operator fun set (key: Any, value: Any) { threadLocal.get()[key] = value }</span>
}

/**
 * Executes a lambda until no exception is thrown or a number of times is reached.
 *
 * @param times Number of times to try to execute the callback. Must be greater than 0.
 * @param delay Milliseconds to wait to next execution if there was an error. Must be 0 or greater.
 * @return The callback result if succeed.
 * @throws [ServiceException] if the callback didn't succeed in the given times.
 */
fun &lt;T&gt; retry (times: Int, delay: Long, func: () -&gt; T): T {
<span class="fc bfc" id="L80" title="All 4 branches covered.">    require (times &gt; 0)</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">    require (delay &gt;= 0)</span>

<span class="fc" id="L83">    val exceptions = mutableListOf&lt;Exception&gt;()</span>
<span class="pc bpc" id="L84" title="1 of 4 branches missed.">    for (ii in 1 .. times) {</span>
<span class="fc" id="L85">        try {</span>
<span class="fc" id="L86">            return func ()</span>
        }
<span class="fc" id="L88">        catch (e: Exception) {</span>
<span class="fc" id="L89">            exceptions.add (e)</span>
<span class="fc" id="L90">            Thread.sleep (delay)</span>
        }
    }

<span class="fc" id="L94">    throw ServiceException(0, &quot;Error retrying $times times ($delay ms)&quot;, *exceptions.toTypedArray())</span>
}

/*
 * Networking
 */

/** Unknown host name. */
<span class="fc" id="L102">val UNKNOWN_LOCALHOST = &quot;UNKNOWN_LOCALHOST&quot;</span>

/** The hostname of the machine running this program. */
<span class="pc bpc" id="L105" title="2 of 4 branches missed.">val hostname = getLocalHost()?.getHostName() ?: UNKNOWN_LOCALHOST</span>
/** The IP address of the machine running this program. */
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">val ip = getLocalHost()?.getHostAddress() ?: UNKNOWN_LOCALHOST</span>

fun parseQueryParameters(query: String): Map&lt;String, String&gt; =
<span class="fc bfc" id="L110" title="All 4 branches covered.">    if (query.isEmpty())</span>
<span class="fc" id="L111">        mapOf()</span>
    else
<span class="pc bpc" id="L113" title="2 of 4 branches missed.">        query.split(&quot;&amp;&quot;.toRegex())</span>
<span class="fc" id="L114">            .map {</span>
<span class="fc" id="L115">                val kv = it.split(&quot;=&quot;)</span>
<span class="pc bpc" id="L116" title="2 of 6 branches missed.">                kv[0].trim () to (if (kv.size == 2) kv[1].trim() else &quot;&quot;)</span>
            }
<span class="fc" id="L118">            .toMap(LinkedHashMap&lt;String, String&gt;())</span>

/*
 * Error handling
 */

/**
 * Returns the stack trace array of the frames that starts with the given prefix.
 */
fun Throwable.filterStackTrace (prefix: String) =
<span class="fc bfc" id="L128" title="All 4 branches covered.">    if (prefix.isEmpty ())</span>
<span class="fc" id="L129">        this.stackTrace</span>
    else
<span class="fc bfc" id="L131" title="All 2 branches covered.">        this.stackTrace.filter { it.className.startsWith (prefix) }.toTypedArray()</span>

/**
 * Returns this throwable as a text.
 */
fun Throwable.toText (prefix: String = &quot;&quot;): String =
<span class="fc" id="L137">    &quot;${this.javaClass.name}: ${this.message}&quot; +</span>
<span class="fc" id="L138">        this.filterStackTrace(prefix).map { &quot;\tat ${it.toString()}&quot; }.joinToString(EOL, EOL) +</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (this.cause == null)</span>
<span class="fc" id="L140">            &quot;&quot;</span>
        else
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            &quot;${EOL}Caused by: &quot; + (this.cause as Throwable).toText (prefix)</span>

/*
 * Logging
 */

<span class="fc" id="L148">internal val flarePrefix = getProperty (&quot;CompanionLogger.flarePrefix&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)</span>
<span class="fc" id="L149">val jvmId = getRuntimeMXBean().name</span>

/*
 * Map operations
 */

@Suppress(&quot;UNCHECKED_CAST&quot;)
operator fun Map&lt;*, *&gt;.get(vararg keys: Any): Any? =
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (keys.size &gt; 1)</span>
<span class="fc" id="L158">        keys</span>
<span class="fc" id="L159">            .dropLast(1)</span>
<span class="fc" id="L160">            .fold(this) { result, element -&gt;</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                val r = result as Map&lt;Any, Any&gt;</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                val value = r.getOrElse(element, { mapOf&lt;Any, Any&gt;() })</span>
<span class="fc" id="L163">                when (value) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                    is Map&lt;*, *&gt; -&gt; value</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                    is List&lt;*&gt; -&gt; value.mapIndexed { ii, item -&gt; ii to item  }.toMap()</span>
<span class="fc" id="L166">                    else -&gt; mapOf&lt;Any, Any&gt;()</span>
<span class="fc" id="L167">                }</span>
            }[keys.last()]
    else
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">        (this as Map&lt;Any, Any&gt;).getOrElse(keys.first()) { null }</span>

/*
 * I/O
 */
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">val systemClassLoader: ClassLoader = getSystemClassLoader() ?: error(&quot;Error getting class loader&quot;)</span>

<span class="fc" id="L177">fun resourceAsStream(resName: String): InputStream? = systemClassLoader.getResourceAsStream(resName)</span>
<span class="fc" id="L178">fun resource(resName: String): URL? = systemClassLoader.getResource(resName)</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">fun requireResource(resName: String): URL = resource(resName) ?: error(&quot;$resName not found&quot;)</span>
fun resources(resName: String): List&lt;URL&gt; =
<span class="nc" id="L181">    systemClassLoader.getResources(resName).toList().filterNotNull()</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>