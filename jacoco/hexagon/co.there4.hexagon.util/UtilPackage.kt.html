<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UtilPackage.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hexagon</a> &gt; <a href="index.source.html" class="el_package">co.there4.hexagon.util</a> &gt; <span class="el_source">UtilPackage.kt</span></div><h1>UtilPackage.kt</h1><pre class="source lang-java linenums">package co.there4.hexagon.util

import co.there4.hexagon.settings.SettingsManager
import java.io.InputStream
import java.lang.System.*
import java.lang.ThreadLocal.withInitial
import java.net.InetAddress.getLocalHost
import java.time.LocalDateTime
import java.util.*
import java.lang.management.ManagementFactory.getRuntimeMXBean
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneOffset.UTC
import java.lang.ClassLoader.getSystemClassLoader
import java.net.URL
import java.time.LocalTime

/*
 * Timing
 */

/**
 * Returns a time difference in nanoseconds formatted as a string.
 */
<span class="fc" id="L25">fun formatNanos(timestamp: Long) = &quot;%1.3f ms&quot;.format (timestamp / 1e6)</span>

/**
 * Formats a date as a formatted integer with this format: `YYYYMMDDHHmmss`.
 */
fun LocalDateTime.asNumber(): Long =
<span class="fc" id="L31">    (this.toLocalDate().asNumber() * 1e9.toLong()) +</span>
<span class="fc" id="L32">    this.toLocalTime().asNumber()</span>

fun LocalDate.asNumber(): Int =
<span class="fc" id="L35">    (this.year       * 1e4.toInt()) +</span>
<span class="fc" id="L36">    (this.monthValue * 1e2.toInt()) +</span>
<span class="fc" id="L37">    this.dayOfMonth</span>

fun LocalTime.asNumber(): Int =
<span class="fc" id="L40">    (this.hour       * 1e7.toInt()) +</span>
<span class="fc" id="L41">    (this.minute     * 1e5.toInt()) +</span>
<span class="fc" id="L42">    (this.second     * 1e3.toInt()) +</span>
<span class="fc" id="L43">    (this.nano / 1e6.toInt()) // Nanos to millis</span>

/**
 * Parses a date from a formatted integer with this format: `YYYYMMDDHHmmss`.
 */
<span class="fc" id="L48">fun Long.toLocalDateTime(): LocalDateTime = (this / 1e9).toInt()</span>
<span class="fc" id="L49">    .toLocalDate()</span>
<span class="fc" id="L50">    .atTime((this % 1e9.toLong()).toInt().toLocalTime())</span>

<span class="fc" id="L52">fun Int.toLocalDate(): LocalDate = LocalDate.of(</span>
    this / 1e4.toInt(),
    (this % 1e4.toInt()) / 1e2.toInt(),
    this % 1e2.toInt()
<span class="fc" id="L56">)</span>

<span class="fc" id="L58">fun Int.toLocalTime(): LocalTime = LocalTime.of(</span>
    (this / 1e7.toInt()),
    ((this % 1e7.toInt()) / 1e5.toInt()),
    ((this % 1e5.toInt()) / 1e3.toInt()),
    ((this % 1e3.toInt()) * 1e6.toInt()) // Millis to nanos
<span class="fc" id="L63">)</span>

<span class="fc" id="L65">fun LocalDateTime.toDate(): Date = Date.from(this.toInstant(UTC))</span>
<span class="nc" id="L66">fun LocalDate.toDate(): Date = this.atStartOfDay().toDate()</span>

fun Date.toLocalDateTime(): LocalDateTime =
<span class="nc" id="L69">    LocalDateTime.ofInstant(Instant.ofEpochMilli(this.time), UTC)</span>

<span class="nc" id="L71">fun Date.toLocalDate(): LocalDate = this.toLocalDateTime().toLocalDate()</span>

/*
 * Threading
 */

/** Map for storing context data linked to the executing thread. */
<span class="fc" id="L78">object Context {</span>
<span class="fc" id="L79">    private val threadLocal = withInitial { LinkedHashMap&lt;Any, Any&gt;() }</span>
<span class="fc" id="L80">    fun entries () = threadLocal.get().entries</span>
<span class="fc" id="L81">    operator fun get (key: Any) = threadLocal.get()[key]</span>
<span class="fc" id="L82">    operator fun set (key: Any, value: Any) { threadLocal.get()[key] = value }</span>
}

/**
 * Executes a lambda until no exception is thrown or a number of times is reached.
 *
 * @param times Number of times to try to execute the callback. Must be greater than 0.
 * @param delay Milliseconds to wait to next execution if there was an error. Must be 0 or greater.
 * @return The callback result if succeed.
 * @throws [ServiceException] if the callback didn't succeed in the given times.
 */
fun &lt;T&gt; retry (times: Int, delay: Long, func: () -&gt; T): T {
<span class="fc bfc" id="L94" title="All 4 branches covered.">    require (times &gt; 0)</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">    require (delay &gt;= 0)</span>

<span class="fc" id="L97">    val exceptions = mutableListOf&lt;Exception&gt;()</span>
<span class="pc bpc" id="L98" title="1 of 4 branches missed.">    for (ii in 1 .. times) {</span>
<span class="fc" id="L99">        try {</span>
<span class="fc" id="L100">            return func ()</span>
        }
<span class="fc" id="L102">        catch (e: Exception) {</span>
<span class="fc" id="L103">            exceptions.add (e)</span>
<span class="fc" id="L104">            Thread.sleep (delay)</span>
        }
    }

<span class="fc" id="L108">    throw ServiceException(0, &quot;Error retrying $times times ($delay ms)&quot;, *exceptions.toTypedArray())</span>
}

/*
 * Networking
 */

/** Unknown host name. */
<span class="fc" id="L116">val UNKNOWN_LOCALHOST = &quot;UNKNOWN_LOCALHOST&quot;</span>

/** The hostname of the machine running this program. */
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">val hostname = getLocalHost()?.hostName ?: UNKNOWN_LOCALHOST</span>
/** The IP address of the machine running this program. */
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">val ip = getLocalHost()?.hostAddress ?: UNKNOWN_LOCALHOST</span>

fun parseQueryParameters(query: String): Map&lt;String, String&gt; =
<span class="fc bfc" id="L124" title="All 4 branches covered.">    if (query.isEmpty())</span>
<span class="fc" id="L125">        mapOf()</span>
    else
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">        query.split(&quot;&amp;&quot;.toRegex())</span>
<span class="fc" id="L128">            .map {</span>
<span class="fc" id="L129">                val kv = it.split(&quot;=&quot;)</span>
<span class="pc bpc" id="L130" title="2 of 6 branches missed.">                kv[0].trim () to (if (kv.size == 2) kv[1].trim() else &quot;&quot;)</span>
            }
<span class="fc" id="L132">            .toMap(LinkedHashMap&lt;String, String&gt;())</span>

/*
 * Error handling
 */

/**
 * Returns the stack trace array of the frames that starts with the given prefix.
 */
fun Throwable.filterStackTrace (prefix: String) =
<span class="fc bfc" id="L142" title="All 4 branches covered.">    if (prefix.isEmpty ())</span>
<span class="fc" id="L143">        this.stackTrace</span>
    else
<span class="fc bfc" id="L145" title="All 2 branches covered.">        this.stackTrace.filter { it.className.startsWith (prefix) }.toTypedArray()</span>

/**
 * Returns this throwable as a text.
 */
fun Throwable.toText (prefix: String = &quot;&quot;): String =
<span class="fc" id="L151">    &quot;${this.javaClass.name}: ${this.message}&quot; +</span>
<span class="fc" id="L152">        this.filterStackTrace(prefix).map { &quot;\tat ${it.toString()}&quot; }.joinToString(EOL, EOL) +</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (this.cause == null)</span>
<span class="fc" id="L154">            &quot;&quot;</span>
        else
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            &quot;${EOL}Caused by: &quot; + (this.cause as Throwable).toText (prefix)</span>

/*
 * Logging
 */

<span class="fc" id="L162">internal val flarePrefix = getProperty (&quot;CompanionLogger.flarePrefix&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)</span>
<span class="fc" id="L163">val jvmId: String = getRuntimeMXBean().name</span>

/*
 * Map operations
 */

@Suppress(&quot;UNCHECKED_CAST&quot;)
operator fun Map&lt;*, *&gt;.get(vararg keys: Any): Any? =
<span class="fc bfc" id="L171" title="All 2 branches covered.">    if (keys.size &gt; 1)</span>
<span class="fc" id="L172">        keys</span>
<span class="fc" id="L173">            .dropLast(1)</span>
<span class="fc" id="L174">            .fold(this) { result, element -&gt;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                val r = result as Map&lt;Any, Any&gt;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                val value = r.getOrElse(element, { mapOf&lt;Any, Any&gt;() })</span>
<span class="fc" id="L177">                when (value) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                    is Map&lt;*, *&gt; -&gt; value</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                    is List&lt;*&gt; -&gt; value.mapIndexed { ii, item -&gt; ii to item  }.toMap()</span>
<span class="fc" id="L180">                    else -&gt; mapOf&lt;Any, Any&gt;()</span>
<span class="fc" id="L181">                }</span>
            }[keys.last()]
    else
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">        (this as Map&lt;Any, Any&gt;).getOrElse(keys.first()) { null }</span>

/*
 * I/O
 */
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">val systemClassLoader: ClassLoader = getSystemClassLoader() ?: error(&quot;Error getting class loader&quot;)</span>
<span class="pc" id="L190">val contextClassLoader: ClassLoader = Thread.currentThread().contextClassLoader</span>
<span class="pc" id="L191">val hexagonClassLoader: ClassLoader = SettingsManager::class.java.classLoader</span>

/**
 * TODO Fix class loader issues, use thread class loader or whatever
 * http://www.javaworld.com/article/2077344/core-java/find-a-way-out-of-the-classloader-maze.html
 */
<span class="nc" id="L197">fun resourceAsStream__(resName: String): InputStream? = hexagonClassLoader.getResourceAsStream(resName)</span>
<span class="nc" id="L198">fun resourceAsStream_(resName: String): InputStream? = contextClassLoader.getResourceAsStream(resName)</span>
<span class="fc" id="L199">fun resourceAsStream(resName: String): InputStream? = systemClassLoader.getResourceAsStream(resName)</span>
<span class="fc" id="L200">fun resource(resName: String): URL? = systemClassLoader.getResource(resName)</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">fun requireResource(resName: String): URL = resource(resName) ?: error(&quot;$resName not found&quot;)</span>
fun resources(resName: String): List&lt;URL&gt; =
<span class="nc" id="L203">    systemClassLoader.getResources(resName).toList().filterNotNull()</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>